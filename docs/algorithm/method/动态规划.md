# 动态规划

## 概念

算法设计中的一种方法

将一个问题分解成相互重叠的子问题，通过反复请求子问题，要解决原来的问题

## 动态规划VS分而治之

最关键的区别就是动态规划的子问题是有相互重叠的，而分而治之的子问题是相互独立的

## 场景

### 1. 斐波拉契定律

## 算法题

1. [70] 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

   每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

   解题思路：

   1. 爬到n阶可以在n-1阶怕一个台阶或者在n-2阶爬两个台阶
   2. fn = f(n-1) + f(n-2)
   3. 反复执行：从2循环到n，执行上述公式

   ```js
   var climbStairs = function(n) {
       if (n < 2) return 1
       const dp = [1,1]
       for(let i = 2; i <=n;i++) {
           dp[i] = dp[i-1]+ dp[i-2]
       }
       return dp[n]
   };
   ```

2. 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

   给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

    

   示例 1：

   输入：[1,2,3,1]
   输出：4
   解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
        偷窃到的最高金额 = 1 + 3 = 4 。
   示例 2：

   输入：[2,7,9,3,1]
   输出：12
   解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
        偷窃到的最高金额 = 2 + 9 + 1 = 12 。

   解题思路

   1.  f(k)：表示从前k个房间能够偷窃到的总金额
   2. ak： 表示第k个房间的金额
   3. f(k) = max(f(k-2) + ak, f(k-2))

   